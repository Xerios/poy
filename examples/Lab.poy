import Euler { euler1 }
import List { Filter, IsEmpty }

struct Console {
    log: _ -> (),
}

declare let console: Console
let print = console.log

type {
    ReturnType<Function<_, ret>> = ret
    Parameters<Function<args, _>> = args

    Not<True> = False
    Not<False> = True
    
    L = [[], [A, B], [], [], [C], [D, E, F], []]
    Query = Filter<@fun<lst, Not<IsEmpty<lst>>>, L>
}

struct Person {
    name: Str,
    age: Num,
    city: Str,
}

extend Tuple<[]> {
    let isUnit = true
}

extend Tuple<_::_> {
    let isUnit = false
}

extend Person {
    fun canDrive() {
        self.age >= 18
    }
}

let nath = Person { name: "Nathalie", age: 25, city: "Paris" }
let city = nath.city
print(nath.canDrive())
print(().isUnit)
print((3, "hello").isUnit)

let {
    a = 3 * 7 + 2
    f = n -> n * n
    id = x -> x
}

fun fact(n) {
    if n == 0 { 1 } else { use pred = n - 1 in n * fact(pred) }
}

module A {
    let a = 3
    module B {
        let b = 7
        module C {
            let c = 11
        }
    }
}

declare module Math {
    fun sqrt(x: Num): Num
    let cbrt: Num -> Num
}

let y = use sum = A.a + A.B.b + A.B.C.c in Math.sqrt(fact(sum))
let x = { let x = 3; let y = 7; x * { let x = 11; let y = 17; x + y } - y } + y

extend Num {
    fun isPrime() {
        if self == 2 { return true }
        if self < 2 || self % 2 == 0 { return false }
        mut i = 3

        while i * i <= self {
            if self % i == 0 {
                return false
            }

            i += 2
        }

        true
    }

    fun sqrt() {
        Math.sqrt(self)
    }
}

fun countPrimes(upTo) {
    mut count = if upTo >= 2 { 1 } else { 0 }
    mut i = 3
    
    while i <= upTo {
        if i.isPrime() {
            count += 1
        }

        i += 2
    }

    count
}

print(3.sqrt())