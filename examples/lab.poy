
type {
    ReturnType<Function<args, ret>> = ret
    Parameters<Function<args, ret>> = args

    Fields<Record<fields>> = fields

    Keys<Record<fields>> = KeysAux<fields>
    KeysAux<[]> = []
    KeysAux<(k, v)::tail> = k::KeysAux<tail>

    Values<Record<fields>> = ValuesAux<fields>
    ValuesAux<[]> = []
    ValuesAux<(k, v)::tail> = v::ValuesAux<tail>

    Reverse<lst> = ReverseAux<lst, []>
    ReverseAux<[], rev> = rev
    ReverseAux<h::tl, rev> = ReverseAux<tl, h::rev>

    Unzip<pairs> = UnzipAux<pairs, [], []>
    UnzipAux<[], as, bs> = (Reverse<as>, Reverse<bs>)
    UnzipAux<(a, b)::tail, as, bs> = UnzipAux<tail, a::as, b::bs>

    R = Record<[(Name, Str), (Age, Num), (Pets, Bool)]>
    Query = Unzip<Fields<R>>
}

let {
    a = 3 * 7 + 2
    f = n -> n * n
    id = x -> x
}

fun twice(f) {
    x -> f(f(x))
}

fun main() {
    twice(f)(2.11)
}

let fact = n -> if n == 0 { 1 } else { n * fact(n - 1) }

module B {
    let a = 3
}
